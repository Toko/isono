# -*- coding: utf-8 -*-

module Isono
  module NodeModules
    # Setup mq based event dispatch channels.
    # It prepares a single point topic exchange which receives all the
    # events from publishers. The event consumers setup queues
    # respectively to bound to the exchange. The most of queues
    # have the key string which filters the event. The event publisher
    # puts the key when it sends each new event.
    # 
    # The key consists of two parts with dot separated:
    # event type and the event sender (ie. "event1.sender1").
    # The event publisher can put any format of data into the message
    # body part.
    # 
    # These rules make the message queue broker to work as the event
    # dispacher.
    class EventChannel < Base
      AMQP_EXCHANGE='isono.event'
      
      initialize_hook do
        @amq = node.create_channel
        @amq.prefetch(1)
        @amq.instance_eval {
          def event_exchange
            self.topic(AMQP_EXCHANGE, {:auto_delete=>false})
          end
        }

        # create the exchange
        @amq.event_exchange
      end

      terminate_hook do
        @amq.close
      end

      # @example
      #   publish('ev/event_name', :args=>[1, 2, 3])
      def publish(evname, opts={})
        opts = {:args=>[], :sender=>manifest.node_id}.merge(opts)
        
        body = {
          :event => evname,
          :published_at=> Time.now,
          :sender  => opts[:sender],
          :origin_node  => manifest.node_id,
          :args => opts[:args]
        }
        
        EventMachine.schedule {
          @amq.event_exchange.publish(Serializer.instance.marshal(body),
                                            {:key=>"#{evname}.#{opts[:sender]}"}
                                            )
        }
      end
      
      def subscribe(evname, sender, receiver_id=node.node_id, &blk)
        @amq.queue("#{evname}-#{receiver_id}", {:exclusive=>true}).bind(
                     AMQP_EXCHANGE, :key=>"#{evname}.#{sender}"
                     ).subscribe { |data|
          data = Serializer.instance.unmarshal(data)
          case blk.arity
          when 2
            m = data.delete(:args)
            blk.call(data, m)
          when 1
            blk.call(data[:args])
          else
            blk.call
          end
        }
      end
      
      def unsubscribe(evname, receiver_id=node.node_id)
        EventMachine.schedule {
          q = @amq.queue("#{evname}-#{receiver_id}")
          q.unsubscribe
        }
      end

    end
  end
end
