# -*- coding: utf-8 -*-

require 'thread'
require 'statemachine'
require 'ostruct'

module Isono
  module NodeModules
    class RpcChannel < Base
      include Logger

      class Dispatcher
        class Decorator < Dispatcher
          attr_reader :dispatcher
          
          def initialize(dispatcher)
            raise TypeError unless dispatcher.is_a?(Dispatcher)
            @dispatcher = dispatcher
            
            set_instance_logger(@dispatcher.class.to_s) if self.respond_to? :set_instance_logger
          end
          
          def dispatch(response_ctx, key, args=[])
            dispatcher.dispatch(response_ctx, key, args=[])
          end
        end
        
        def dispatch(response_ctx, key, args=[])
          raise NotImplementedError
        end
      end

      class ProcDispatcher < Dispatcher
        include Logger
        
        def initialize(&blk)
          @table = {}
          blk.call(self) if blk
        end

        def add(key, &blk)
          @table[key] = blk
        end
        
        def dispatch(response_ctx, key, args=[])
          d = @table[key]
          raise "Unknown command: #{key}" if d.nil?
          
          logger.debug("executing command: #{key}")
          ret = d.call(*args)
          response_ctx.response(ret)
        end
      end

      class SyncDispatcher < Dispatcher::Decorator
        include Logger

        def dispatch(response_ctx, key, args=[])
          Thread.new {
            begin
              ret = dispatcher.dispatch(response_ctx, key, args)
            rescue Exception => e
              logger.error(e)
              response_ctx.response(e)
            else
              response_ctx.response(ret) unless response_ctx.responded?
            end
          }
        end
      end      
      
      class ObjectDispatcher < Dispatcher
        include Logger

        def initialize(obj)
          @obj = obj
        end

        def dispatch(response_ctx, key, args=[])
          m = @obj.method(key)
          raise "Unknown command: #{key}" if m.nil?
          
          ret = m.arity > 0 ? m.call(*args) : m.call
          response_ctx.response(ret)
        end
      end

      initialize_hook do
        @active_requests = {}
        @endpoints = {}
                
        amq.queue("command-recv.#{manifest.node_id}", {:exclusive=>true}).subscribe { |header, data|
          event = EventChannel.new(self.node)
          req = @active_requests[header.message_id]
          if req
            data = Serializer.instance.unmarshal(data)
            req.process_event(:on_received, data)
            event.publish('rpc/response_received', manifest.node_id, data)
            begin
              case data[:type]
              when :inprogress
                req.progress_cb.call(data[:msg]) if req.progress_cb
              when :error
                req.process_event(:on_error, data)
                req.error_cb.call(data[:msg]) if req.error_cb
              else
                req.process_event(:on_success, data)
                req.success_cb.call(data[:msg]) if req.success_cb
              end
            rescue => e
              logger.error(e)
            ensure
              if req.state == :done
                @active_requests.delete req.ticket
              end
            end
          end
        }

        # RPC endpoint for statistics info of this node.
        myinstance.register_endpoint("rpc-stats.#{manifest.node_id}", ProcDispatcher.new { |t|
                                       t.add('get') {
                                         {
                                           :active_requests => @active_requests.map {|a| a.hash },
                                           :endpoints => @endpoints.keys
                                         }
                                       }
                                     })
      end

      terminate_hook do
        @endpoints.keys.each { |ns|
          myinstance.unregister_endpoint(ns)
        }
        amq.queue("command-recv.#{manifest.node_id}", {:exclusive=>true}).delete
      end

      # Make async RPC request to an endpoint
      # 
      # @param [String] endpoint
      # @param [String] command
      # @param [Array] args
      # @param [Proc] &blk Setup the request context.
      # @example
      #   rpc.async_request('endpoint1', 'func1', )
      # @example Create oneshot call. (do not expect response) 
      #   rpc.async_request('endpoint1', 'func1') { |req|
      #     req.oneshot = false
      #   }
      def request(endpoint, command, *args, &blk)
        req = AsyncRequestContext.new(endpoint, command, args)
        # the block is to setup the request context  prior to sending.
        blk.call(req) if blk
        
        if req.timeout_sec > 0.0
          # register the timeout hook.
          req.timer = EventMachine::Timer.new(req.timeout_sec) {
            @active_requests.delete req.ticket
            req.error_cb.call(:timeout) if req.error_cb
          }
        end
        
        req.process_event(:on_ready)
        
        # use amq.direct exchange
        EventMachine.schedule {
          if !req.oneshot
            @active_requests[req.ticket] = req
          end
          
          amq.direct('', {:key=>endpoint_queue_name(endpoint)}).
          publish(Serializer.instance.marshal(req.request.dup),
                  {:message_id => req.ticket,
                    :key => endpoint_queue_name(endpoint),
                    :reply_to=>"command-recv.#{manifest.node_id}"}
                  )
          
          req.process_event(:on_sent)
          event.publish('rpc/request_sent', manifest.node_id, req.hash)
        }
        req
      end
      
      # @param [String] endpoint
      # @param [Dispatcher] dispatcher
      def register_endpoint(endpoint, dispatcher)
        raise TypeError unless dispatcher.is_a?(Dispatcher)
        @endpoints[endpoint]=dispatcher

        # create receive queue for new RPC endpoint.
        amq.queue(endpoint_queue_name(endpoint), {:exclusive=>true}).subscribe(:ack=>true) { |header, data|
          data = Serializer.instance.unmarshal(data)
          event.publish('rpc/request_received', manifest.node_id, data)

          resctx = if data[:oneshot]
                     OneshotResponseContext.new(self.node, header)
                   else
                     ResponseContext.new(self.node, header)
                   end
          begin
            ret = dispatcher.dispatch(resctx, data[:command], data[:args])
          rescue Exception => e
            logger.error(e)
            resctx.response(e) unless resctx.responded?
          end
        }
        event.publish('rpc/register', {:endpoint=>endpoint})
      end
      

      def unregister_endpoint(endpoint)
        if @endpoints.delete(endpoint)
          amq.queue(endpoint_queue_name(endpoint), {:exclusive=>true}).delete
          event.publish('rpc/unregister', {:endpoint=>endpoint})
        end
      end
      
      private
      def endpoint_queue_name(ns)
        "isono.rpc.endpoint.#{ns}"
      end

      def event
        EventChannel.new(node)
      end

      class ResponseContext
        def initialize(node, header)
          @responded = false
          @node = node
          @header = header
        end

        def responded?
          @responded
        end

        def progress(ret)
          EM.schedule {
            publish(:inprogress, ret)
          }
        end

        def response(ret)
          raise "" if @responded

          EM.schedule {
            @header.ack
            if ret.is_a? Exception
              publish(:error, {:message=> ret.message, :error_type => ret.class.to_s})
            else
              publish(:success, ret)
            end
            EventChannel.new(@node).publish('rpc/response_sent', @node.node_id, ret)
          }
          @responded = true
        end


        private
        def publish(type, body)
          @node.amq.queue(@header.reply_to).publish(Serializer.instance.marshal({:type=>type, :msg=>body}),
                                                   {:key=>@header.reply_to,
                                                     :message_id=>@header.message_id}
                                                   )
        end
      end

      # Do nothing when the response is tried to send back in case of
      # oneshot request.
      class OneshotResponseContext < ResponseContext
        def progress(ret)
        end

        def response(ret)
          raise "" if @responded

          EM.schedule {
            @header.ack
            EventChannel.new(@node).publish('rpc/response_sent', @node.node_id, ret)
          }
          @responded = true
        end
      end

      class AsyncRequestContext < OpenStruct
        # They are not to be appeared in @table so that won't be inspect().
        attr_reader :error_cb, :success_cb, :progress_cb
        attr_accessor :timer

        def initialize(endpoint, command, args)
          super({:request=>{
                    :endpoint=> endpoint,
                    :command => command,
                    :args => args
                  }.freeze,
                  :ticket => Util.gen_id,
                  :timeout_sec => 0.0,
                  :oneshot => false,
                  :sent_at => nil,
                  :completed_at => nil,
                  :complete_status => nil,
                })
          
          @success_cb = nil
          @progress_cb = nil
          @error_cb = nil
          @timer = nil

          @stm = Statemachine.build {
            trans :init, :on_ready, :ready
            trans :ready, :on_sent, :waiting, proc { self.sent_at=Time.now}
            trans :waiting, :on_received, :waiting
            trans :waiting, :on_error, :done, proc {
              self.completed_at=Time.now
              @timer.cancel if @timer
              self.complete_status = :fail
            }
            trans :waiting, :on_success, :done, proc {
              self.completed_at=Time.now
              @timer.cancel if @timer
              self.complete_status = :success
            }
          }
          @stm.context = self
        end

        def state
          @stm.state
        end

        def process_event(ev, *args)
          @stm.process_event(ev, *args)
        end

        def hash
          # state, sent_at received_at are readonly values so they are
          # not pushed in @table.
          @table.dup.merge({:state=>self.state})
        end

        def on_success=(cb)
          raise ArgumentError unless cb.is_a? Proc
          @success_cb = cb
        end

        def on_progress=(cb)
          raise ArgumentError unless cb.is_a? Proc
          @progress_cb = cb
        end

        def on_error=(cb)
          raise ArgumentError unless cb.is_a? Proc
          @error_cb = cb
        end

        def on_success(&blk)
          raise ArgumentError unless blk
          @success_cb = blk
        end

        def on_progress(&blk)
          raise ArgumentError unless blk
          @progress_cb = blk
        end

        def on_error(&blk)
          raise ArgumentError unless blk
          @error_cb = blk
        end
      end

    end
  end
end
