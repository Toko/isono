# -*- coding: utf-8 -*-

require 'thread'
require 'statemachine'
require 'ostruct'

module Isono
  module NodeModules
    class RpcChannel < Base
      include Logger

      AMQP_EXCHANGE='isono.rpc'

      class RpcError < RuntimeError; end
      class UnknownEndpointError < RpcError; end
      class DuplicateEndpointError < RpcError; end

      config_section do
        desc "default timeout duration in second until receive response."
        timeout_sec (60*3).to_f
      end

      initialize_hook do
        @active_requests = {}
        @endpoints = {}
        amq.direct(AMQP_EXCHANGE, {:auto_delete=>true})
        amq.queue("command-recv.#{manifest.node_id}", {:exclusive=>true}).subscribe { |header, data|
          event = EventChannel.new(self.node)
          req = @active_requests[header.message_id]
          if req
            data = Serializer.instance.unmarshal(data)
            req.process_event(:on_received, data)
            event.publish('rpc/response_received', :args=>[header.message_id])
            begin
              case data[:type]
              when :inprogress
                req.progress_cb.call(data[:msg]) if req.progress_cb
              when :error
                req.process_event(:on_error, data)
                req.error_cb.call(data[:msg]) if req.error_cb
              else
                req.process_event(:on_success, data)
                req.success_cb.call(data[:msg]) if req.success_cb
              end
            rescue => e
              logger.error(e)
            ensure
              if req.state == :done
                @active_requests.delete req.ticket
              end
            end
          end
        }

        # RPC endpoint for statistics info of this node.
        myinstance.register_endpoint("rpc-stats.#{manifest.node_id}", proc { |req, res|
                                       case req.command
                                       when 'get'
                                         res.response({:active_requests => @active_requests.map {|a| a.hash },
                                                        :endpoints => @endpoints.keys
                                                      })
                                       else
                                         raise Rack::UnknownMethodError
                                       end
                                     })
      end

      terminate_hook do
        @endpoints.keys.each { |ns|
          myinstance.unregister_endpoint(ns)
        }
        amq.queue("command-recv.#{manifest.node_id}", {:exclusive=>true}).delete
      end

      # Make a RPC request to an endpoint.
      # 
      # @param [String] endpoint
      # @param [String] command
      # @param [Array] args
      # @param [Proc] &blk Block to setup the request context.
      # @return [RequestContext,any]
      #
      # @example create a sync RPC request.
      #   rpc.request('endpoint1', 'func1', xxxx)
      # @example call RPC in async mode.
      #   rpc.request('endpoint1', 'func1', xxxx) { |req|
      #     req.on_success { |r|
      #       puts r
      #     }
      #     req.on_error { |r|
      #       puts r
      #     }
      #   }
      #
      # @example setup request context and do wait().
      #   Note that callbacks are 
      #   rpc.request('endpoint1', 'func1', xxxx) { |req|
      #     # send new attribute
      #     req.request[:xxxx] = "sdfsdf"
      #     # returns synchronized RequestContext to block caller.
      #     req.synchronize
      #   }.wait # request() get back the altered RequestCotenxt that has wait().
      #
      # @example Create async oneshot call. (do not expect response) 
      #   rpc.request('endpoint1', 'func1') { |req|
      #     req.oneshot = true
      #   }
      def request(endpoint, command, *args, &blk)
        req = RequestContext.new(endpoint, command, args)
        # the block is to setup the request context prior to sending.
        if blk
          # async 
          r = blk.call(req)
          req = r if r.is_a?(RequestContext)
          if req.oneshot
            send_request(req)
          else
            check_endpoint(endpoint) { |result|
              if result
                send_request(req)
              else
                req.error_cb(UnknownEndpointError.new(endpoint))
              end
            }
          end

          req
        else
          # sync
          req = req.synchronize
          check_endpoint(endpoint) || raise(UnknownEndpointError, endpoint)
          send_request(req)
          req.wait
        end
      end

      # Register a new RPC endpoint.
      #
      # This method works in sync mode if called at non-EM reactor thread.
      # @param [String] endpoint
      # @param [has call() method]  app
      # @param [Hash] opts
      def register_endpoint(endpoint, app, opts={})
        raise TypeError unless app.respond_to?(:call)
        opts = {:exclusive=>true}.merge(opts)
        @endpoints[endpoint]={:app=>app, :opts=>opts}
        
        # create receive queue for new RPC endpoint.
        endpoint_proc = proc { |header, data|

          data = Serializer.instance.unmarshal(data)
          event.publish('rpc/request_received', :args=>[header.message_id])

          resctx = if data[:oneshot]
                     OneshotResponseContext.new(self.node, header)
                   else
                     ResponseContext.new(self.node, header)
                   end
          begin
            req = Rack::Request.new({:sender=>header.reply_to['command-recv.'.size..-1],
                                      :message_id=>header.message_id
                                    }.merge(data))
            res = Rack::Response.new(resctx)
            ret = app.call(req, res)
          rescue Exception => e
            logger.error(e)
            resctx.response(e) unless resctx.responded?
          end
        }

        setup_proc = proc {
          amq.queue(endpoint_queue_name(endpoint), {:exclusive=>false, :auto_delete=>true}).bind(
                    AMQP_EXCHANGE, {:key=>endpoint_queue_name(endpoint)}
                    ).subscribe(:ack=>true, &endpoint_proc) 
          event.publish('rpc/register', :args=>[endpoint])
        }

        dm = Util::DeferedMsg.new(30)
        
        EventMachine.schedule {
          amq.queue(endpoint_queue_name(endpoint), {:exclusive=>false, :auto_delete=>true}).status { |messages, consumers|
            if opts[:exclusive]
              if consumers.to_i == 0
                setup_proc.call
                dm.success
              else
                dm.error(DuplicateEndpointError.new("Endpoint is already locked: #{endpoint}"))
              end
            else
              setup_proc.call
              dm.success
            end

            # expect to raise DuplicateEndpointError if endpoint exists.
            # ignore the case of success.
            dm.wait
          }
        }

        dm.wait unless EventMachine.reactor_thread?
      end

      # Unregister endpoint.
      # 
      # @param [String] endpoint endpoint name to be removed
      def unregister_endpoint(endpoint)
        if @endpoints.delete(endpoint)
          dm = Util::DeferedMsg.new(30)
          EventMachine.schedule {
            amq.queue(endpoint_queue_name(endpoint)).delete
            event.publish('rpc/unregister', :args=>[endpoint])
            dm.success
          }
          dm.wait unless EventMachine.reactor_thread?
        end
      end

      # Check if the endpoint exists.
      # @param [String] endpoint endpoint name to be checked
      def check_endpoint(endpoint, &blk)
        if blk
        else
          dm = Util::DeferedMsg.new(30)
        end

        EventMachine.schedule {
          amq.queue(endpoint_queue_name(endpoint), {:exclusive=>false, :auto_delete=>true}).status { |messages, consumers|
            res = consumers.to_i > 0
            if blk
              blk.call(res)
            else
              dm.success(res)
            end
          }
        }
        
        if blk
        else
          dm.wait unless EventMachine.reactor_thread?
        end
      end
      
      private
      def endpoint_queue_name(ns)
        "isono.rpc.endpoint.#{ns}"
      end

      def event
        @event ||= EventChannel.new(node)
      end

      # Publish a RPC request asynchronously.
      # @param [RequestContext] req Request context object to be
      # sent. If the context's state is not :init, it will fail.
      def send_request(req)
        raise TypeError if !req.is_a?(RequestContext)
        raise "Request context seems to be sent already: #{req.state}" if req.state != :init

        # possible timeout_sec values:
        # timeout_sec == -1.0 : to be overwritten to the default timeout.
        # timeout_sec == 0.0  : never be timed out.
        # timeout_sec > 0.0   : wait for the user set timeout.
        if req.timeout_sec == -1.0
          # set default timeout if no one updated the initial value.
          req.timeout_sec = config_section.timeout_sec
        end
        
        if req.timeout_sec > 0.0
          # register the timeout hook.
          req.timer = EventMachine::Timer.new(req.timeout_sec) {
            @active_requests.delete req.ticket
            req.error_cb.call(:timeout) if req.error_cb
          }
        end
        
        req.process_event(:on_ready)
        
        EventMachine.schedule {
          if !req.oneshot
            @active_requests[req.ticket] = req
          end
          
          amq.direct(AMQP_EXCHANGE).publish(
                  Serializer.instance.marshal(req.request_hash),
                  {:message_id => req.ticket,
                    :key => endpoint_queue_name(req.endpoint),
                    :reply_to=>"command-recv.#{manifest.node_id}"}
                  )
          req.process_event(:on_sent)
          event.publish('rpc/request_sent', :args=>[req.hash])
        }
      end

      class ResponseContext
        attr_reader :node, :header
        
        def initialize(node, header)
          @responded = false
          @node = node
          @header = header
        end

        def responded?
          @responded
        end

        def progress(ret)
          EM.schedule {
            publish(:inprogress, ret)
          }
        end

        def response(ret)
          raise "" if @responded

          EM.schedule {
            @header.ack
            if ret.is_a? Exception
              publish(:error, {:message=> ret.message, :error_type => ret.class.to_s})
            else
              publish(:success, ret)
            end
            EventChannel.new(@node).publish('rpc/response_sent', :args=>[@header.message_id])
          }
          @responded = true
        end


        private
        def publish(type, body)
          @node.amq.direct('').publish(Serializer.instance.marshal({:type=>type, :msg=>body}),
                                       {:key=>@header.reply_to,
                                         :message_id=>@header.message_id}
                                       )
        end
      end

      # Do nothing when the endpoint trys to send back in case of
      # oneshot request.
      class OneshotResponseContext < ResponseContext
        def progress(ret)
        end

        def response(ret)
          raise "" if @responded

          EM.schedule {
            @header.ack
            EventChannel.new(@node).publish('rpc/response_sent', :args=>[@header.message_id])
          }
          @responded = true
        end
      end

      class RequestContext < OpenStruct
        # They are not to be appeared in @table so that won't be inspect().
        attr_reader :error_cb, :success_cb, :progress_cb
        attr_accessor :timer

        def initialize(endpoint, command, args)
          super({:request=>{
                    :endpoint=> endpoint,
                    :command => command,
                    :args => args
                  },
                  :endpoint=> endpoint,
                  :command => command,
                  :ticket => Util.gen_id,
                  :timeout_sec => -1.0,
                  :oneshot => false,
                  :sent_at => nil,
                  :completed_at => nil,
                  :complete_status => nil,
                })
          
          @success_cb = nil
          @progress_cb = nil
          @error_cb = nil
          @timer = nil

          @stm = Statemachine.build {
            trans :init, :on_ready, :ready
            trans :ready, :on_sent, :waiting, proc {
              self.sent_at=Time.now
              # freeze request hash not to be modified after sending.
              self.request.freeze
            }
            trans :waiting, :on_received, :waiting
            trans :waiting, :on_error, :done, proc {
              self.completed_at=Time.now
              @timer.cancel if @timer
              self.complete_status = :fail
            }
            trans :waiting, :on_success, :done, proc {
              self.completed_at=Time.now
              @timer.cancel if @timer
              self.complete_status = :success
            }
          }
          @stm.context = self
        end

        def state
          @stm.state
        end

        def process_event(ev, *args)
          @stm.process_event(ev, *args)
        end

        def elapsed_time
          self.completed_at.nil? ? nil : (self.completed_at - self.sent_at)
        end

        def hash
          # state, sent_at received_at are readonly values so they are
          # not pushed in @table.
          @table.dup.merge({:state=>self.state})
        end

        def request_hash
          request.merge({:oneshot=>oneshot})
        end

        def on_success(&blk)
          raise ArgumentError unless blk
          @success_cb = blk
        end

        def on_progress(&blk)
          raise ArgumentError unless blk
          @progress_cb = blk
        end

        def on_error(&blk)
          raise ArgumentError unless blk
          @error_cb = blk
        end

        def synchronize
          self.extend RequestSynchronize
          self
        end

        module RequestSynchronize
          def self.extended(mod)
            raise TypeError, "This module is applicable only for RequestContext" unless mod.is_a?(RequestContext)
            # overwrite callbacks
            mod.instance_eval {
              @q = ::Queue.new
              
              on_success { |r|
                @q << [:success, r]
              }
              on_error { |r|
                @q << [:error, r]
              }
            }
          end

          public
          def wait()
            raise "response was received already." if state == :done
            raise "wait() has to be called at outside of the EventMachine's main loop." if EventMachine.reactor_thread?
            
            r = @q.deq
            
            case r[0]
            when :success
              r[1]
            when :error
              raise RpcError, r[1]
            end
          end
        end
        
      end
      
    end
  end
end
