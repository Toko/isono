# -*- coding: utf-8 -*-

require 'statemachine'

module Isono
  module NodeModules
    class JobWorker < Base
      include Logger

      JOB_CTX_KEY=:job_worker_ctx
      
      initialize_hook do
        @thread_pool = ThreadPool.new(10)
        @active_jobs = {}

        RpcChannel.new(node).register_endpoint("job-stats.#{node.node_id}",
                                               RpcChannel::ProcDispatcher.new { |d|
                                                 d.add('get') {
                                                   { :active_jobs => @active_jobs.map {|j| j.to_hash } }
                                                 }
                                               })
      end

      terminate_hook do
        @thread_pool.shutdown
      end

      def run(parent_id=nil, &blk)
        job = JobContext.new(parent_id)
        @active_jobs[job.job_id] = job
        rpc = RpcChannel.new(node)

        rpc.request('job-collector', 'regist') { |req|
          req.oneshot = true
        }
        
        @thread_pool.pass {
          job.stm.on_start
          rpc.request('job-collector', 'update') { |req|
            req.oneshot = true
          }
          
          begin
            Thread.current[JOB_CTX_KEY]=job
            blk.call
            job.stm.on_done
          rescue Exception => e
            job.stm.on_fail(e)
          ensure
            Thread.current[JOB_CTX_KEY]=nil
            EventMachine.schedule {
              rpc.request('job-collector', 'update') { |req|
                req.oneshot = true
              }
              @active_jobs.delete(job.job_id)
            }
          end
        }
        job
      end

      class JobDispatcher < RpcChannel::Dispatcher::Decorator
        include Logger
        
        def initialize(dispatcher, job_worker)
          super(dispatcher)
          @job_worker = job_worker
        end
        
        def dispatch(resctx, key, args=[])
          
          job = @job_worker.run(){
            begin
              dispatcher.dispatch(reqctx, key, args)
            
              resctx.response(1) unless resctx.responded
            ensure
            end
          }
          resctx.progress({:job_id=>job.job_id})
        end
      end

      class JobContext < OpenStruct

        attr_reader :stm
        
        def initialize(parent_id=nil)
          super({:job_id=>Util.gen_id,
                  :parent_job_id=> parent_id,
                  :started_at=>nil,
                  :finished_at=>nil,
                })


          @stm = Statemachine.build {
            startstate :init
            trans :init,   :on_start,  :running, :on_start
            trans :running, :on_done, :done, :on_done
            trans :running, :on_fail, :failed, :on_fail
            trans :init,   :on_fail, :failed, :on_fail
          }
          @stm.context = self
        end

        
        def to_hash
          @table.dup.merge({:state=>@stm.state})
        end

        private
        def on_start
          self.started_at = Time.now
        end

        def on_done
          self.finished_at = Time.now
        end

        def on_fail
          self.finished_at = Time.now
        end
        
      end
      
    end
  end
end
