# -*- coding: utf-8 -*-
require 'ostruct'

module Isono
  module NodeModules
    class JobWorker < Base
      include Logger

      JOB_CTX_KEY=:job_worker_ctx

      config_section do |c|
        desc "Concurrency number of worker thread."
        c.concurrency = 1
      end
      
      initialize_hook do
        @thread_pool = ThreadPool.new(config_section.concurrency.to_i, 'JobWorker')
        @active_jobs = {}

        RpcChannel.new(node).register_endpoint("job-stats.#{node.node_id}", proc { |req, res|
                                                 case res.command
                                                 when 'get'
                                                   res.response({ :active_jobs => @active_jobs.map {|j| j.to_hash } })
                                                 else
                                                   raise Rack::UnknownMethodError
                                                 end
                                               })
      end

      terminate_hook do
        @thread_pool.shutdown
      end

      # Start a new long term job.
      #
      # @yield The block to setup JobContext object.
      # 
      # @example Initialize JobContext within the block.
      #  start { |ctx|
      #    # setup JobContext
      #    ctx.job_id = 'xxxx'
      #    ctx.parent_job_id = 'yyyy'
      #  }
      def start(&blk)
        job = JobContext.new()
        blk.call(job)
        @active_jobs[job.job_id] = job
        rpc = RpcChannel.new(node)

        rpc.request('job-collector', 'regist', job.to_hash) { |req|
          req.oneshot = true
        }
        
        @thread_pool.pass {
          begin
            Thread.current[JOB_CTX_KEY]=job
            job.process_event(:on_start)
            rpc.request('job-collector', 'update', job.to_hash) { |req|
              req.oneshot = true
            }
            job.run_cb.call
            job.process_event(:on_done)
          rescue Exception => e
            job.process_event(:on_fail, e)
            if job.fail_cb
              begin
                job.fail_cb.arity == 1 ? job.fail_cb.call(e) : job.fail_cb.call
              rescue Exception => e
                logger.error("Failed to call the failure call back #{job.fail_cb}: #{job_id}: #{e}")
                logger.error(e)
              end
            end
          ensure
            Thread.current[JOB_CTX_KEY]=nil
            EventMachine.schedule {
              rpc.request('job-collector', 'update', job.to_hash) { |req|
                req.oneshot = true
              }
              @active_jobs.delete(job.job_id)
            }
          end
        }
        job
      end

      # Run the block/proc. This is simple utility method for start().
      #
      # @param [Proc,nil] run_cb
      # @param [Proc,nil] fail_cb
      #
      # @example Run 
      #  run {
      #    puts "message"
      #  }
      # @example Use proc{} for setting both run and fail block.
      #  run(proc{
      #        # do something
      #      }, proc{
      #        # do rollback on fail
      #      })
      def run(run_cb=nil, fail_cb=nil, &blk)
        if run_cb.is_a?(Proc)
          start do |job|
            job.run_cb = run_cb
            job.fail_cb = fail_cb if fail_cb.is_a?(Proc)
          end
        elsif blk
          start do |job|
            job.run_cb = blk
          end
        end
      end

      class JobContext < OpenStruct
        include Logger
        attr_accessor :run_cb, :fail_cb
        attr_reader :state
        
        def initialize()
          job_id = Util.gen_id
          super({:job_id        => job_id,
                 :parent_job_id => nil,
                 :session_id    => job_id,
                 :started_at    => nil,
                 :finished_at   => nil,
                 :finish_status => nil,
                })
          @run_cb=proc{}
          @fail_cb=nil

          @state = :init
        end

        def process_event(ev, *args)
          case [ev,@state]
          when [:on_start, :init]
            @state = :running
            self.started_at = Time.now
            logger.info("Job start #{session_id}")
          when [:on_done, :running]
            @state = :done
            self.finished_at = Time.now
            logger.info("Job complete #{session_id}: #{elapsed_time} sec")
          when [:on_fail, :running]
            @state = :failed
            on_fail(args[0])
          when [:on_fail, :init]
            @state = :failed
            on_fail(args[0])
          else
            raise "Unknown state transition: #{ev}, #{@state}"
          end
        end
        
        def to_hash
          @table.dup.merge({:state=>@state})
        end

        def elapsed_time
          if finished_at && started_at
            finished_at - started_at
          else
            0
          end
        end

        private
        def on_fail(e)
          self.finished_at = Time.now
          logger.error("Job failed #{session_id}: #{e}")
          logger.error(e)
        end
        
      end
      
    end
  end
end
