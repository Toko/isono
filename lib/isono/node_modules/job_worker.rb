# -*- coding: utf-8 -*-

require 'statemachine'

module Isono
  module NodeModules
    class JobWorker < Base
      include Logger

      JOB_CTX_KEY=:job_worker_ctx
      
      initialize_hook do
        @thread_pool = ThreadPool.new(10)
        @active_jobs = {}

        RpcChannel.new(node).register_endpoint("job-stats.#{node.node_id}", proc { |req, res|
                                                 case res.command
                                                 when 'get'
                                                   res.response({ :active_jobs => @active_jobs.map {|j| j.to_hash } })
                                                 else
                                                   raise Rack::UnknownMethodError
                                                 end
                                               })
      end

      terminate_hook do
        @thread_pool.shutdown
      end

      def run(parent_id=nil, &blk)
        job = JobContext.new(parent_id)
        @active_jobs[job.job_id] = job
        rpc = RpcChannel.new(node)

        rpc.request('job-collector', 'regist', job.to_hash) { |req|
          req.oneshot = true
        }
        
        @thread_pool.pass {
          job.stm.on_start
          rpc.request('job-collector', 'update', job.to_hash) { |req|
            req.oneshot = true
          }
          
          begin
            Thread.current[JOB_CTX_KEY]=job
            blk.call
            job.stm.on_done
          rescue Exception => e
            job.stm.on_fail(e)
          ensure
            Thread.current[JOB_CTX_KEY]=nil
            EventMachine.schedule {
              rpc.request('job-collector', 'update', job.to_hash) { |req|
                req.oneshot = true
              }
              @active_jobs.delete(job.job_id)
            }
          end
        }
        job
      end

      class JobContext < OpenStruct

        attr_reader :stm
        
        def initialize(parent_id=nil)
          super({:job_id=>Util.gen_id,
                  :parent_job_id=> parent_id,
                  :started_at=>nil,
                  :finished_at=>nil,
                })


          @stm = Statemachine.build {
            startstate :init
            trans :init,   :on_start,  :running, :on_start
            trans :running, :on_done, :done, :on_done
            trans :running, :on_fail, :failed, :on_fail
            trans :init,   :on_fail, :failed, :on_fail
          }
          @stm.context = self
        end

        def state
          stm.state
        end
        
        def to_hash
          @table.dup.merge({:state=>@stm.state})
        end

        private
        def on_start
          self.started_at = Time.now
        end

        def on_done
          self.finished_at = Time.now
        end

        def on_fail
          self.finished_at = Time.now
        end
        
      end
      
    end
  end
end
