# -*- coding: utf-8 -*-

require 'statemachine'

module Isono
  module NodeModules
    class JobWorker < Base
      include Logger

      JOB_CTX_KEY=:job_worker_ctx
      
      initialize_hook do
        @thread_pool = ThreadPool.new(10)
        @active_jobs = {}

        RpcChannel.new(node).register_endpoint("job-stats.#{node.node_id}", proc { |req, res|
                                                 case res.command
                                                 when 'get'
                                                   res.response({ :active_jobs => @active_jobs.map {|j| j.to_hash } })
                                                 else
                                                   raise Rack::UnknownMethodError
                                                 end
                                               })
      end

      terminate_hook do
        @thread_pool.shutdown
      end

      # Start a new long term job.
      #
      # @param [String] parent_id Parent Job ID for new job
      # @param [Proc,nil] run_cb
      # @param [Proc,nil] fail_cb
      # @yield The block used as run_cb
      # 
      # @example Simply set run block as yield block and parent job ID.
      #  run('xxxxxx') {
      #    # do something
      #  }
      # @example Set proc{} to both run and fail block.
      #  run(proc{
      #        # do something
      #      }, proc{
      #        # do rollback on fail
      #      })
      def run(parent_id=nil, run_cb=nil, fail_cb=nil, &blk)
        if run_cb.is_a?(Proc)
          job = JobContext.new(run_cb, parent_id)
          job.fail_cb = fail_cb if fail_cb.is_a?(Proc)
        elsif blk
          job = JobContext.new(blk, parent_id)
        else
          raise ArgumentError, "callbacks were not set propery"
        end
        @active_jobs[job.job_id] = job
        rpc = RpcChannel.new(node)

        rpc.request('job-collector', 'regist', job.to_hash) { |req|
          req.oneshot = true
        }
        
        @thread_pool.pass {
          begin
            Thread.current[JOB_CTX_KEY]=job
            job.stm.on_start
            rpc.request('job-collector', 'update', job.to_hash) { |req|
              req.oneshot = true
            }
            job.run_cb.call
            job.stm.on_done
          rescue Exception => e
            job.stm.on_fail(e)
            if job.fail_cb
              job.fail_cb.arity == 1 ? job.fail_cb.call(e) : job.fail_cb.call
            end
          ensure
            Thread.current[JOB_CTX_KEY]=nil
            EventMachine.schedule {
              rpc.request('job-collector', 'update', job.to_hash) { |req|
                req.oneshot = true
              }
              @active_jobs.delete(job.job_id)
            }
          end
        }
        job
      end

      class JobContext < OpenStruct

        attr_reader :stm, :run_cb
        attr_accessor :fail_cb
        
        def initialize(run_cb, parent_id=nil)
          super({:job_id=>Util.gen_id,
                  :parent_job_id=> parent_id,
                  :started_at=>nil,
                  :finished_at=>nil,
                })

          @run_cb=run_cb
          @fail_cb=nil

          @stm = Statemachine.build {
            startstate :init
            trans :init,   :on_start,  :running, :on_start
            trans :running, :on_done, :done, :on_done
            trans :running, :on_fail, :failed, :on_fail
            trans :init,   :on_fail, :failed, :on_fail
          }
          @stm.context = self
        end

        def state
          stm.state
        end
        
        def to_hash
          @table.dup.merge({:state=>@stm.state})
        end

        private
        def on_start
          self.started_at = Time.now
        end

        def on_done
          self.finished_at = Time.now
        end

        def on_fail(e)
          self.finished_at = Time.now
        end
        
      end
      
    end
  end
end
