# -*- coding: utf-8 -*-

module Isono
  module NodeModules
    class JobChannel < Base

      config_section do |c|
        desc "default timeout duration in second"
        c.timeout_sec = (60*60*24).to_f
        desc "default job concurrency"
        c.concurrency = 1
      end

      # Send a new job request to the endpoint.
      #
      # @param [String] endpoint endpoint name created by JobChannel#register_endpoint()
      # @param [String] command command name in the endpoint.
      # @param [any] *args arguments to run the job.
      # @yieldparam [RpcChannel::RequestContext] modify RPC request before sending. The
      #   method will stop the current thread if it does not exist.
      # @return [Rack::Request,String] Request object if the block is given.
      #
      # @example call job endpoint 'endpoint1'.
      #  puts  submit('endpoint1', 'command1', 1, 2, 3) # => show Job ID
      def submit(endpoint, command, *args, &blk)
        req = run(endpoint, command, *args) { |req|
          blk.call(req) if blk
        }

        req.request[:job_id]
      end

      # Send a new job request and wait until the job finished.
      # The difference to submit() is that this method will stop the
      # thread until the called job completed.
      #
      # @param [String] endpoint endpoint name created by JobChannel#register_endpoint()
      # @param [String] command command name in the endpoint.
      # @param [any] *args arguments to run the job.
      # @yieldparam [RpcChannel::RequestContext] modify RPC request before sending. The
      #   method will stop the current thread if it does not exist.
      # 
      # @example wait while the job running.
      #   run('endpoint1', 'command1', 1, 2, 3) #=> result of 'endpoint1/command1'.
      # @example receive progress messages from long running job.
      #   run('endpoint1', 'command1', 1, 2, 3) do |req|
      #      req.on_progress { |r|
      #        puts r #=> show progress message
      #      }
      #   end
      def run(endpoint, command, *args, &blk)
        cur_job_ctx = Thread.current[JobWorker::JOB_CTX_KEY]
        req = rpc.request("job.#{endpoint}", command, *args) { |req|
          req.timeout_sec = config_section.timeout_sec
          req.request[:job_id] = Util.gen_id
          req.request[:session_id] = req.request[:job_id]
          req.request[:job_name] = command
         
          # A job is working on this current thread if cur_job_ctx is
          # not nil. Let the new job know the current job ID
          # as its parent job ID.
          if cur_job_ctx
            req.request[:parent_job_id] = cur_job_ctx.job_id
            req.request[:session_id] = cur_job_ctx.session_id
          end

          blk ? blk.call(req) : req.synchronize
        }

        blk ? req : req.wait
      end
      
      def cancel(job_id)
      end
      
      def register_endpoint(endpoint, app, opts={})
        opts = {:concurrency=>config_section.concurrency}.merge(opts)
        rpc.register_endpoint("job.#{endpoint}", Rack::Job.new(app, JobWorker.new(node)), {:prefetch=>opts[:concurrency]})
      end

      private
      def rpc
        @rpc ||= RpcChannel.new(@node)
      end
      
    end
  end
end
