# -*- coding: utf-8 -*-

module Isono
  module NodeModules
    class JobChannel < Base

      # Send a new job request to the endpoint and get back job ID.
      #
      # @param [String] endpoint endpoint name created by JobChannel#register_endpoint()
      # @param [String] command command name in the endpoint.
      # @param [any] *args arguments to run the job.
      # @yieldparam [RpcChannel::RequestContext] modify RPC request before sending. The
      #   method will stop the current thread if it does not exist.
      # @return [Rack::Request,String] Request object if the block is given.
      #
      # @example call job endpoint 'endpoint1' and receive 
      #   submit('endpoint1', 'command1', 1, 2, 3) #=> Job ID.
      def submit(endpoint, command, *args, &blk)
        cur_job_ctx = Thread.current[JobWorker::JOB_CTX_KEY]
        req = rpc.request("job.#{endpoint}", command, *args) { |req|
          req.request[:job_request_type]=:submit

          # A job is working on this current thread if cur_job_ctx is
          # not nil. Let the new job know the current job ID
          # as its parent job ID.
          if cur_job_ctx
            req.request[:parent_job_id] = cur_job_ctx.job_id
          end

          blk ? blk.call(req) : req.synchronize
        }

        blk ? req : req.wait
      end

      # Send a new job request and wait until the job finished.
      # The difference to submit() is that this method will stop the
      # thread until the called job completed.
      #
      # @param [String] endpoint endpoint name created by JobChannel#register_endpoint()
      # @param [String] command command name in the endpoint.
      # @param [any] *args arguments to run the job.
      # @yieldparam [RpcChannel::RequestContext] modify RPC request before sending. The
      #   method will stop the current thread if it does not exist.
      # 
      # @example wait while the job running.
      #   run('endpoint1', 'command1', 1, 2, 3) #=> result of 'endpoint1/command1'.
      # @example receive progress messages from long running job.
      #   run('endpoint1', 'command1', 1, 2, 3) do |req|
      #      req.on_progress { |r|
      #        puts r #=> show progress message
      #      }
      #   end
      def run(endpoint, command, *args, &blk)
        cur_job_ctx = Thread.current[JobWorker::JOB_CTX_KEY]
        req = rpc.request("job.#{endpoint}", command, *args) { |req|
          req.request[:job_request_type]=:run

          # A job is working on this current thread if cur_job_ctx is
          # not nil. Let the new job know the current job ID
          # as its parent job ID.
          if cur_job_ctx
            req.request[:parent_job_id] = cur_job_ctx.job_id
          end

          blk ? blk.call(req) : req.synchronize
        }

        blk ? req : req.wait
      end
      
      def cancel()
      end
      
      def register_endpoint(endpoint, app)
        rpc.register_endpoint("job.#{endpoint}", Rack::Job.new(app, JobWorker.new(node)))
      end

      private
      def rpc
        @rpc ||= RpcChannel.new(@node)
      end
      
    end
  end
end
